name: Deploy ToGather Microservices to AWS EKS

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: ap-northeast-2
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.ap-northeast-2.amazonaws.com
  EKS_CLUSTER_NAME: togather-cluster
  EKS_NAMESPACE: togather
  # CDN ì„¤ì •!
  CDN_URL: https://d36ue99r8i68ow.cloudfront.net
  S3_BUCKET_NAME: togather-static-assets
  CLOUDFRONT_DISTRIBUTION_ID: E15ZDIW40YBVEN

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set gradlew permissions
        run: chmod +x gradlew

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Checkout Client Repo # ToGather-Client ì ‘ê·¼!
        uses: actions/checkout@v4
        with:
          repository: ToGather-Final/ToGather-Client
          token: ${{ secrets.GH_PAT }}
          path: togather-client

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Cache pnpm dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.pnpm-store
            togather-client/node_modules
          key: ${{ runner.os }}-pnpm-${{ hashFiles('togather-client/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Cache Gradle packages
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Build with Gradle
        run: |
          chmod +x gradlew
          ./gradlew build -x test

      #    - name: Build and push Next.js Client image
      #      run: |
      #        docker build -t $ECR_REGISTRY/togather/client:${{ github.sha }} -f ./togather-client/Dockerfile ./togather-client
      #        docker build -t $ECR_REGISTRY/togather/client:latest -f ./togather-client/Dockerfile ./togather-client
      #        docker push $ECR_REGISTRY/togather/client:${{ github.sha }}
      #        docker push $ECR_REGISTRY/togather/client:latest

      - name: Build Next.js Client and upload static assets
        run: |
          cd togather-client
          export CDN_URL_CLEAN=$(echo "${{ env.CDN_URL }}" | sed 's:/*$::')
          echo "ğŸ›° Using CDN_URL=$CDN_URL_CLEAN"
          
          pnpm install --frozen-lockfile
          
          # âœ… Next.js ë¹Œë“œ (ë‹¨ 1íšŒ)
          SERVER_API_BASE_URL=http://api-gateway.togather.svc.cluster.local:8000/api \
          NEXT_PUBLIC_API_BASE_URL=https://xn--o79aq2k062a.store/api \
          CDN_URL=$CDN_URL_CLEAN pnpm run build
          
          # âœ… ë¹Œë“œ ì‚°ì¶œë¬¼ ì•„í‹°íŒ©íŠ¸ë¡œ ë³´ê´€ (Dockerì™€ S3ì—ì„œ ë™ì¼ ë¹Œë“œ ì‚¬ìš©)
          cd ..
          tar -czf next-artifacts.tgz -C togather-client .next/standalone .next/static .next/server public
          echo "âœ… next-artifacts.tgz ìƒì„± ì™„ë£Œ"
          
          # âœ… ì •ì  ìì‚° ì—…ë¡œë“œ ë° CDN ë¬´íš¨í™”
          cd togather-client
          pnpm run upload-assets
        env:
          CDN_URL: ${{ env.CDN_URL }}
          S3_BUCKET_NAME: ${{ env.S3_BUCKET_NAME }}
          CLOUDFRONT_DISTRIBUTION_ID: ${{ env.CLOUDFRONT_DISTRIBUTION_ID }}
          NEXT_PUBLIC_API_BASE_URL: https://xn--o79aq2k062a.store

        # âœ… next-artifacts.tgz íŒŒì¼ì„ ì—…ë¡œë“œ (ë¹Œë“œ ê²°ê³¼ ë°±ì—…)
      - name: Upload Next build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: next-artifacts
          path: next-artifacts.tgz

        # âœ… ë¹Œë“œ ê²°ê³¼ë¥¼ Docker ì´ë¯¸ì§€ ìƒì„±ì— ì¬ì‚¬ìš©
      - name: Download Next.js build artifacts
        uses: actions/download-artifact@v4
        with:
          name: next-artifacts
          path: ./togather-client

        echo "âœ… Next.js build completed. Checking output structure..."
        ls -R .next | head -n 40

        # âœ… server.js ê²€ì¦
        if [ ! -f ".next/standalone/server.js" ]; then
          echo "âŒ .next/standalone/server.js not found!"
          echo "ë¹Œë“œ ì‚°ì¶œë¬¼ ëˆ„ë½. ë¹Œë“œ ì‹¤íŒ¨ë¡œ ê°„ì£¼í•©ë‹ˆë‹¤."
          exit 1
        fi

        # âœ… ë¹Œë“œ ì‚°ì¶œë¬¼ ì•„í‹°íŒ©íŠ¸ë¡œ ë³´ê´€ (Dockerì™€ S3ì—ì„œ ë™ì¼ ë¹Œë“œ ì‚¬ìš©)
        cd ..
        tar -czf next-artifacts.tgz -C togather-client .next/standalone .next/static public
        echo "âœ… next-artifacts.tgz ìƒì„± ì™„ë£Œ"

        # âœ… kr ë„ì…ì„ ìœ„í•´ ì¶”ê°€ --build-arg CDN_URL=${{ env.CDN_URL }} \
      - name: Build and push Next.js runtime image
        run: |
          docker build \
            --build-arg SERVER_API_BASE_URL=http://api-gateway.togather.svc.cluster.local:8000/api \
            --build-arg NEXT_PUBLIC_API_BASE_URL=https://xn--o79aq2k062a.store/api \
            --build-arg CDN_URL=${{ env.CDN_URL }} \
            -t $ECR_REGISTRY/togather/client:${{ github.sha }} \
            -f ./togather-client/Dockerfile ./togather-client
          docker tag $ECR_REGISTRY/togather/client:${{ github.sha }} $ECR_REGISTRY/togather/client:latest
          docker push $ECR_REGISTRY/togather/client:${{ github.sha }}
          docker push $ECR_REGISTRY/togather/client:latest

    - name: Upload Next build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: next-artifacts
        path: next-artifacts.tgz

    - name: Download Next.js build artifacts
      uses: actions/download-artifact@v4
      with:
        name: next-artifacts
        path: ./togather-client

    - name: Extract Next.js artifacts
      run: |
        tar -xzf ./togather-client/next-artifacts.tgz -C ./togather-client
        echo "âœ… next-artifacts.tgz ì••ì¶• í•´ì œ ì™„ë£Œ"
        ls -R ./togather-client/.next/standalone | head -n 20

      # âœ… kr ë„ì…ì„ ìœ„í•´ ì¶”ê°€ --build-arg CDN_URL=${{ env.CDN_URL }} \
    - name: Build and push Next.js runtime image
      run: |
        echo "ğŸš€ Building Next.js runtime image..."
        cd togather-client

        # ë¹Œë“œ ì‚°ì¶œë¬¼ ê²€ì¦
        if [ ! -f ".next/standalone/server.js" ]; then
          echo "âŒ server.js not found in .next/standalone â€” build failed!"
          ls -R .next | head -n 40
          exit 1
        fi

        docker build \
          --build-arg SERVER_API_BASE_URL=http://api-gateway.togather.svc.cluster.local:8000/api \
          --build-arg NEXT_PUBLIC_API_BASE_URL=https://xn--o79aq2k062a.store/api \
          --build-arg CDN_URL=${{ env.CDN_URL }} \
          -t $ECR_REGISTRY/togather/client:${{ github.sha }} \
          -t $ECR_REGISTRY/togather/client:latest \
          -f Dockerfile .

        docker push $ECR_REGISTRY/togather/client:${{ github.sha }}
        docker push $ECR_REGISTRY/togather/client:latest

      - name: Build and push Vote Service image
        run: |
          docker build -f vote-service/Dockerfile -t $ECR_REGISTRY/togather/vote-service:${{ github.sha }} .
          docker build -f vote-service/Dockerfile -t $ECR_REGISTRY/togather/vote-service:latest .
          docker push $ECR_REGISTRY/togather/vote-service:${{ github.sha }}
          docker push $ECR_REGISTRY/togather/vote-service:latest

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl for EKS
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Deploy to EKS
        if: github.ref == 'refs/heads/main'
        run: |
          # 1. ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ìƒì„± (ì—†ìœ¼ë©´ ìƒì„±, ìˆìœ¼ë©´ ë„˜ì–´ê°)
          kubectl apply -f k8s/namespace.yaml
          
          # 2. Secret ìƒì„± (ëª¨ë“  ë¯¼ê° ì •ë³´ë¥¼ GitHub Secretsì—ì„œ ê°€ì ¸ì™€ í†µí•©)
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Secret
          metadata:
            name: togather-secrets
            namespace: ${{ env.EKS_NAMESPACE }}
          type: Opaque
          stringData:
            SPRING_DATASOURCE_USERNAME: "${{ secrets.DB_USERNAME }}"
            SPRING_DATASOURCE_PASSWORD: "${{ secrets.DB_PASSWORD }}"
            DB_USERNAME: "${{ secrets.DB_USERNAME }}"
            DB_PASSWORD: "${{ secrets.DB_PASSWORD }}"
            JWT_SECRET_KEY: "${{ secrets.JWT_SECRET_KEY }}"
            JWT_SECRET: "${{ secrets.JWT_SECRET_KEY }}"
            SPRING_RABBITMQ_USERNAME: "admin"
            SPRING_RABBITMQ_PASSWORD: "${{ secrets.RABBITMQ_PASSWORD }}"
            RABBITMQ_USERNAME: "admin"
            RABBITMQ_PASSWORD: "${{ secrets.RABBITMQ_PASSWORD }}"
            REDIS_PASSWORD: "${{ secrets.REDIS_PASSWORD }}"
            SPRING_DATA_REDIS_PASSWORD: "${{ secrets.REDIS_PASSWORD }}"
            # KIS ì¦ê¶Œ API í™˜ê²½ë³€ìˆ˜
            KIS_BASE_URL: "${{ secrets.KIS_BASE_URL }}"
            KIS_APPKEY: "${{ secrets.KIS_APPKEY }}"
            KIS_APPSECRET: "${{ secrets.KIS_APPSECRET }}"
          EOF
          
          # 3. RBAC ë¨¼ì € ì ìš© (ServiceAccount/Role/RoleBinding)
          kubectl apply -f k8s/api-gateway-rbac.yaml -n ${{ env.EKS_NAMESPACE }}
          
          # 4. í™˜ê²½ë³€ìˆ˜ ì¹˜í™˜ í›„ ë‚˜ë¨¸ì§€ ëª¨ë“  ë¦¬ì†ŒìŠ¤ ë°°í¬
          # ECR_REGISTRYì™€ CERTIFICATE_ARN í™˜ê²½ë³€ìˆ˜ë¥¼ k8s íŒŒì¼ë“¤ì— ì¹˜í™˜
          export ECR_REGISTRY=${{ env.ECR_REGISTRY }}
          export CERTIFICATE_ARN=${{ secrets.CERTIFICATE_ARN }}
          
          # í™˜ê²½ë³€ìˆ˜ ì¹˜í™˜ì´ í•„ìš”í•œ íŒŒì¼ë“¤ ë°°í¬
          envsubst < k8s/api-gateway.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}
          envsubst < k8s/user-service.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}
          envsubst < k8s/trading-service.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}
          envsubst < k8s/pay-service.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}
          envsubst < k8s/vote-service.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}
          envsubst < k8s/nextjs-client.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}
          envsubst < k8s/ingress.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}
          
          # ë‚˜ë¨¸ì§€ ë¦¬ì†ŒìŠ¤ë“¤ (ConfigMap, Service, HPA ë“±) ë°°í¬
          kubectl apply -f k8s/configmap.yaml -n ${{ env.EKS_NAMESPACE }}
          kubectl apply -f k8s/configmap-env.yaml -n ${{ env.EKS_NAMESPACE }}
          kubectl apply -f k8s/redis.yaml -n ${{ env.EKS_NAMESPACE }}
          kubectl apply -f k8s/rabbitmq.yaml -n ${{ env.EKS_NAMESPACE }}
          # ingress.yamlê³¼ nextjs-client.yamlì€ ìœ„ì—ì„œ envsubstë¡œ ì´ë¯¸ ë°°í¬ë¨
          kubectl apply -f k8s/hpa.yaml -n ${{ env.EKS_NAMESPACE }}  # ğŸš€ HPA ì¬í™œì„±í™”    
          
          # 5. ê° ë””í”Œë¡œì´ë¨¼íŠ¸ì— ì»¤ë°‹ SHA ì´ë¯¸ì§€ ì„¤ì • (ë¡¤ì•„ì›ƒ íŠ¸ë¦¬ê±°)
          kubectl set image deployment/api-gateway api-gateway=${{ env.ECR_REGISTRY }}/togather/api-gateway:${{ github.sha }} -n ${{ env.EKS_NAMESPACE }} --record=true
          kubectl set image deployment/user-service user-service=${{ env.ECR_REGISTRY }}/togather/user-service:${{ github.sha }} -n ${{ env.EKS_NAMESPACE }} --record=true
          kubectl set image deployment/trading-service trading-service=${{ env.ECR_REGISTRY }}/togather/trading-service:${{ github.sha }} -n ${{ env.EKS_NAMESPACE }} --record=true
          kubectl set image deployment/pay-service pay-service=${{ env.ECR_REGISTRY }}/togather/pay-service:${{ github.sha }} -n ${{ env.EKS_NAMESPACE }} --record=true
          kubectl set image deployment/vote-service vote-service=${{ env.ECR_REGISTRY }}/togather/vote-service:${{ github.sha }} -n ${{ env.EKS_NAMESPACE }} --record=true
          kubectl set image deployment/nextjs-client nextjs-client=${{ env.ECR_REGISTRY }}/togather/client:${{ github.sha }} -n ${{ env.EKS_NAMESPACE }} --record=true

      - name: Invalidate CloudFront Cache
        if: github.ref == 'refs/heads/main'
        uses: chetan/invalidate-cloudfront-action@v2
        env:
          DISTRIBUTION: ${{ env.CLOUDFRONT_DISTRIBUTION_ID }}
          PATHS: "/*" # ğŸ’¡ ëª¨ë“  íŒŒì¼(*)ì„ ë¬´íš¨í™”í•˜ì—¬ ì¦‰ì‹œ ë³€ê²½ì‚¬í•­ ë°˜ì˜d
          AWS_REGION: "us-east-1" # ì¸ì¦ì„œëŠ” us-east-1ì— ìˆì–´ì•¼ í•˜ë¯€ë¡œ ëª…ì‹œ
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Wait for deployment to complete
        if: github.ref == 'refs/heads/main'
        run: |
          # ë°°í¬ ê²°ê³¼ ì¶”ì ì„ ìœ„í•œ ë³€ìˆ˜ ì´ˆê¸°í™”
          FAILED_SERVICES=""
          SUCCESS_SERVICES=""
          
          # Redis ë°°í¬ í™•ì¸
          echo "ğŸš€ Redis ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
          if kubectl rollout status deployment/redis -n ${{ env.EKS_NAMESPACE }} --timeout=60s; then
            echo "âœ… Redis ë°°í¬ ì„±ê³µ"
            SUCCESS_SERVICES="$SUCCESS_SERVICES redis"
          else
            echo "âŒ Redis ë°°í¬ ì‹¤íŒ¨! ì§„ë‹¨ ì •ë³´ ì¶œë ¥ ì¤‘..."
            FAILED_SERVICES="$FAILED_SERVICES redis"
            kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=redis
            kubectl describe deployment redis -n ${{ env.EKS_NAMESPACE }}
            POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=redis -o jsonpath='{.items[0].metadata.name}')
            kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
            kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=100 || true
          fi
          
          # API Gateway ë°°í¬ í™•ì¸!!
          echo ""
          echo "ğŸš€ API Gateway ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
          if kubectl rollout status deployment/api-gateway -n ${{ env.EKS_NAMESPACE }} --timeout=240s; then
            echo "âœ… API Gateway ë°°í¬ ì„±ê³µ"
            SUCCESS_SERVICES="$SUCCESS_SERVICES api-gateway"
          else
            echo "âŒ API Gateway ë°°í¬ ì‹¤íŒ¨! ì§„ë‹¨ ì •ë³´ ì¶œë ¥ ì¤‘..."
            FAILED_SERVICES="$FAILED_SERVICES api-gateway"
            kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=api-gateway
            kubectl describe deployment api-gateway -n ${{ env.EKS_NAMESPACE }}
            POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=api-gateway -o jsonpath='{.items[0].metadata.name}')
            kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
            kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=100 || true
          fi
          
          # User Service ë°°í¬ í™•ì¸
          echo ""
          echo "ğŸš€ User Service ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
          if kubectl rollout status deployment/user-service -n ${{ env.EKS_NAMESPACE }} --timeout=180s; then
            echo "âœ… User Service ë°°í¬ ì„±ê³µ"
            SUCCESS_SERVICES="$SUCCESS_SERVICES user-service"
          else
            echo "âŒ User Service ë°°í¬ ì‹¤íŒ¨! ì§„ë‹¨ ì •ë³´ ì¶œë ¥ ì¤‘..."
            FAILED_SERVICES="$FAILED_SERVICES user-service"
            kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=user-service
            kubectl describe deployment user-service -n ${{ env.EKS_NAMESPACE }}
            POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=user-service -o jsonpath='{.items[0].metadata.name}')
            kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
            kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=100 || true
          fi
          
          # Trading Service ë°°í¬ í™•ì¸
          echo ""
          echo "ğŸš€ Trading Service ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
          if kubectl rollout status deployment/trading-service -n ${{ env.EKS_NAMESPACE }} --timeout=180s; then
            echo "âœ… Trading Service ë°°í¬ ì„±ê³µ"
            SUCCESS_SERVICES="$SUCCESS_SERVICES trading-service"
          else
            echo "âŒ Trading Service ë°°í¬ ì‹¤íŒ¨! ì§„ë‹¨ ì •ë³´ ì¶œë ¥ ì¤‘..."
            FAILED_SERVICES="$FAILED_SERVICES trading-service"
            kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=trading-service
            kubectl describe deployment trading-service -n ${{ env.EKS_NAMESPACE }}
            POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=trading-service -o jsonpath='{.items[0].metadata.name}')
            kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
            kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=100 || true
          fi
          
          # Pay Service ë°°í¬ í™•ì¸
          echo ""
          echo "ğŸš€ Pay Service ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
          if kubectl rollout status deployment/pay-service -n ${{ env.EKS_NAMESPACE }} --timeout=180s; then
            echo "âœ… Pay Service ë°°í¬ ì„±ê³µ"
            SUCCESS_SERVICES="$SUCCESS_SERVICES pay-service"
          else
            echo "âŒ Pay Service ë°°í¬ ì‹¤íŒ¨! ì§„ë‹¨ ì •ë³´ ì¶œë ¥ ì¤‘..."
            FAILED_SERVICES="$FAILED_SERVICES pay-service"
            kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=pay-service
            kubectl describe deployment pay-service -n ${{ env.EKS_NAMESPACE }}
            POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=pay-service -o jsonpath='{.items[0].metadata.name}')
            kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
            kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=100 || true
          fi
          
          # Vote Service ë°°í¬ í™•ì¸
          echo ""
          echo "ğŸš€ Vote Service ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
          if kubectl rollout status deployment/vote-service -n ${{ env.EKS_NAMESPACE }} --timeout=180s; then
            echo "âœ… Vote Service ë°°í¬ ì„±ê³µ"
            SUCCESS_SERVICES="$SUCCESS_SERVICES vote-service"
          else
            echo "âŒ Vote Service ë°°í¬ ì‹¤íŒ¨! ì§„ë‹¨ ì •ë³´ ì¶œë ¥ ì¤‘..."
            FAILED_SERVICES="$FAILED_SERVICES vote-service"
            kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=vote-service
            kubectl describe deployment vote-service -n ${{ env.EKS_NAMESPACE }}
            POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=vote-service -o jsonpath='{.items[0].metadata.name}')
            kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
            kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=100 || true
          fi
          
          # Next.js Client ë°°í¬ í™•ì¸
          echo ""
          echo "ğŸš€ Next.js Client ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
          if kubectl rollout status deployment/nextjs-client -n ${{ env.EKS_NAMESPACE }} --timeout=120s; then
            echo "âœ… Next.js Client ë°°í¬ ì„±ê³µ"
            SUCCESS_SERVICES="$SUCCESS_SERVICES nextjs-client"
          else
            echo "âŒ Next.js Client ë°°í¬ ì‹¤íŒ¨! ì§„ë‹¨ ì •ë³´ ì¶œë ¥ ì¤‘..."
            FAILED_SERVICES="$FAILED_SERVICES nextjs-client"
            kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=nextjs-client
            kubectl describe deployment nextjs-client -n ${{ env.EKS_NAMESPACE }}
            POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=nextjs-client -o jsonpath='{.items[0].metadata.name}')
            kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
            kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=100 || true
          fi
          
          # ìµœì¢… ë°°í¬ ê²°ê³¼ ìš”ì•½
          echo ""
          echo "=================================================="
          echo "ğŸ“Š ë°°í¬ ê²°ê³¼ ìš”ì•½"
          echo "=================================================="
          
          if [ -n "$SUCCESS_SERVICES" ]; then
            echo "âœ… ì„±ê³µí•œ ì„œë¹„ìŠ¤:$SUCCESS_SERVICES"
          fi
          
          if [ -n "$FAILED_SERVICES" ]; then
            echo "âŒ ì‹¤íŒ¨í•œ ì„œë¹„ìŠ¤:$FAILED_SERVICES"
            echo ""
            echo "âš ï¸ ì¼ë¶€ ì„œë¹„ìŠ¤ ë°°í¬ê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤!"
            exit 1
          else
            echo ""
            echo "ğŸ‰ ëª¨ë“  ì„œë¹„ìŠ¤ ë°°í¬ ì™„ë£Œ!"
          fi

      - name: Verify deployment
        if: github.ref == 'refs/heads/main'
        run: |
          kubectl get pods -n ${{ env.EKS_NAMESPACE }}
          kubectl get services -n ${{ env.EKS_NAMESPACE }}
          kubectl get ingress -n ${{ env.EKS_NAMESPACE }}

      - name: Prewarm Next.js Client
        if: github.ref == 'refs/heads/main'
        run: |
          echo "ğŸ”¥ Next.js í´ë¼ì´ì–¸íŠ¸ Prewarming ì‹œì‘..."
          SITE_URL="https://xn--o79aq2k062a.store"
          
          # ë°°í¬ ì™„ë£Œ ëŒ€ê¸° (ìµœëŒ€ 2ë¶„)
          echo "â³ Next.js í´ë¼ì´ì–¸íŠ¸ ì¤€ë¹„ ëŒ€ê¸° ì¤‘..."
          for i in {1..24}; do
            if kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=nextjs-client -o jsonpath='{.items[0].status.conditions[?(@.type=="Ready")].status}' | grep -q "True"; then
              echo "âœ… Next.js í´ë¼ì´ì–¸íŠ¸ ì¤€ë¹„ ì™„ë£Œ!"
              break
            fi
            echo "ëŒ€ê¸° ì¤‘... ($i/24)"
            sleep 5
          done
          
          # Prewarming ìš”ì²­ (5íšŒ)
          echo "ğŸ”¥ ì›Œë°ì—… ìš”ì²­ ì „ì†¡ ì¤‘..."
          for i in {1..5}; do
            STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$SITE_URL" || echo "000")
            if [ "$STATUS_CODE" = "200" ]; then
              echo "âœ… ì›Œë°ì—… ìš”ì²­ $i/5 ì„±ê³µ (HTTP $STATUS_CODE)"
            else
              echo "âš ï¸ ì›Œë°ì—… ìš”ì²­ $i/5 ì‹¤íŒ¨ (HTTP $STATUS_CODE)"
            fi
            sleep 1
          done
          
          echo "ğŸ‰ Prewarming ì™„ë£Œ! ì‚¬ìš©ìë“¤ì´ ë¹ ë¥¸ ì‘ë‹µì„ ê²½í—˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

      - name: Diagnostics on failure
        if: failure()
        run: |
          kubectl get deploy -n ${{ env.EKS_NAMESPACE }}
          kubectl describe deploy api-gateway -n ${{ env.EKS_NAMESPACE }}
          kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=api-gateway -o wide
          POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=api-gateway -o jsonpath='{.items[0].metadata.name}')
          kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
          kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=200 || true
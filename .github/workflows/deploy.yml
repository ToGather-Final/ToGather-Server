name: Deploy ToGather Microservices to AWS EKS

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: ap-northeast-2
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.ap-northeast-2.amazonaws.com
  EKS_CLUSTER_NAME: togather-cluster
  EKS_NAMESPACE: togather
  CDN_URL: https://d36ue99r8i68ow.cloudfront.net
  S3_BUCKET_NAME: togather-static-assets
  CLOUDFRONT_DISTRIBUTION_ID: E15ZDIW40YBVEN

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      # --- ê³µí†µ ì¤€ë¹„ ë‹¨ê³„ ---!!
      - name: Checkout Server Repository
        uses: actions/checkout@v4

      - name: Set gradlew permissions
        run: chmod +x gradlew

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Checkout Client Repository
        uses: actions/checkout@v4
        with:
          repository: ToGather-Final/ToGather-Client
          token: ${{ secrets.GH_PAT }}
          path: togather-client

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Cache pnpm dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.pnpm-store
            togather-client/node_modules
          key: ${{ runner.os }}-pnpm-${{ hashFiles('togather-client/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-

      - name: Setup JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Cache Gradle packages
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      # --- Next.js í´ë¼ì´ì–¸íŠ¸ ë¨¼ì € ë¹Œë“œ (ë¹ ë¥¸ í”¼ë“œë°±) ---
      - name: Build Next.js Client (Priority)
        run: |
          cd togather-client
          export CDN_URL_CLEAN=$(echo "${{ env.CDN_URL }}" | sed 's:/*$::')
          echo "ğŸ›° Using CDN_URL=$CDN_URL_CLEAN"

          pnpm install --frozen-lockfile

          # âœ… Next.js ë‹¨ì¼ ë¹Œë“œ (Node runtime)
          SERVER_API_BASE_URL=http://api-gateway.togather.svc.cluster.local:8000/api \
          NEXT_PUBLIC_API_BASE_URL=https://xn--o79aq2k062a.store/api \
          NEXT_PUBLIC_WS_URL=wss://xn--o79aq2k062a.store/ws \
          CDN_URL=$CDN_URL_CLEAN pnpm run build

          # âœ… ë¹Œë“œ ê²°ê³¼ ê²€ì¦ (server.js ë˜ëŠ” next-server.js ì¤‘ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ ì„±ê³µ)
          if [ ! -f ".next/standalone/server.js" ] && [ ! -f ".next/standalone/server.mjs" ] && [ ! -f ".next/standalone/next-server.js" ]; then
            echo "âŒ Next.js standalone server entry not found!"
            echo "ğŸ” Available files in .next/standalone:"
            ls -la .next/standalone/ || echo "No standalone directory found"
            echo "ğŸ” Available files in .next:"
            ls -la .next/ || echo "No .next directory found"
            exit 1
          else
            echo "âœ… Next.js standalone build successful"
            if [ -f ".next/standalone/server.js" ]; then
              echo "âœ… Found server.js"
            fi
            if [ -f ".next/standalone/next-server.js" ]; then
              echo "âœ… Found next-server.js"
            fi
          fi

          # âœ… .next/server ì œì™¸í•˜ê³  ì•„í‹°íŒ©íŠ¸ ìƒì„±
          cd ..
          tar -czf next-artifacts.tgz -C togather-client .next/standalone .next/static public src/app src/components src/contexts src/hooks src/lib src/utils src/constants src/types src/services src/containers
          echo "âœ… next-artifacts.tgz ìƒì„± ì™„ë£Œ"

      # --- Next.js ë¹Œë“œ ì•„í‹°íŒ©íŠ¸ ì—…ë¡œë“œ (1íšŒë§Œ) ---
      - name: Upload Next build artifacts (Priority)
        uses: actions/upload-artifact@v4
        with:
          name: next-artifacts
          path: next-artifacts.tgz

      # --- Docker ë¹Œë“œ ---
      - name: Download and Extract Next.js Build Artifacts (Priority)
        uses: actions/download-artifact@v4
        with:
          name: next-artifacts
          path: ./togather-client

      - name: Extract Next.js Artifacts (Priority)
        run: |
          tar -xzf ./togather-client/next-artifacts.tgz -C ./togather-client
          echo "âœ… next-artifacts.tgz ì••ì¶• í•´ì œ ì™„ë£Œ"

      - name: Build and Push Next.js Runtime Image (Priority)
        continue-on-error: true
        run: |
          echo "ğŸš€ Building Next.js runtime image..."
          cd togather-client
          if docker build \
            --build-arg SERVER_API_BASE_URL=http://api-gateway.togather.svc.cluster.local:8000/api \
            --build-arg NEXT_PUBLIC_API_BASE_URL=https://xn--o79aq2k062a.store/api \
            --build-arg NEXT_PUBLIC_WS_URL=wss://xn--o79aq2k062a.store/ws \
            --build-arg CDN_URL=${{ env.CDN_URL }} \
            -t $ECR_REGISTRY/togather/client:${{ github.sha }} \
            -t $ECR_REGISTRY/togather/client:latest \
            -f Dockerfile .; then
            echo "âœ… Next.js build successful"
            if docker push $ECR_REGISTRY/togather/client:${{ github.sha }} && docker push $ECR_REGISTRY/togather/client:latest; then
              echo "âœ… Next.js Docker image successfully built and pushed!"
            else
              echo "âŒ Next.js push failed"
              exit 1
            fi
          else
            echo "âŒ Next.js build failed"
            exit 1
          fi

      # --- S3 ì •ì  ìì‚° ì—…ë¡œë“œ (ë™ì¼í•œ ë¹Œë“œ ê²°ê³¼ ì‚¬ìš©) ---
      - name: Upload Static Assets to S3 (Priority)
        run: |
          echo "ğŸš€ Uploading static assets to S3..."
          cd togather-client
          
          # âœ… ë™ì¼í•œ ë¹Œë“œ ê²°ê³¼ë¥¼ S3ì— ì—…ë¡œë“œ
          pnpm run upload-assets
          
          echo "âœ… Static assets uploaded to S3 successfully!"
        env:
          CDN_URL: ${{ env.CDN_URL }}
          S3_BUCKET_NAME: ${{ env.S3_BUCKET_NAME }}
          CLOUDFRONT_DISTRIBUTION_ID: ${{ env.CLOUDFRONT_DISTRIBUTION_ID }}

      # --- S3 ë²„í‚· ì •ì±… ì„¤ì • ---
      - name: Configure S3 Bucket Policy for CloudFront
        run: |
          echo "ğŸ”§ Configuring S3 bucket policy for CloudFront access..."
          aws s3api put-bucket-policy \
            --bucket ${{ env.S3_BUCKET_NAME }} \
            --policy file://scripts/s3-bucket-policy.json
          echo "âœ… S3 bucket policy configured successfully!"


      # --- kubectl ì„¤ì¹˜ (Next.js ë°°í¬ë¥¼ ìœ„í•´) ---
      - name: Install kubectl (Priority)
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      # --- Next.js í´ë¼ì´ì–¸íŠ¸ EKS ë°°í¬ (ë¹ ë¥¸ í”¼ë“œë°±) ---
      - name: Deploy Next.js Client to EKS (Priority)
        if: github.ref == 'refs/heads/main'
        run: |
          echo "ğŸš€ Deploying Next.js Client first for quick feedback..."
          
          # kubectl ì„¤ì •
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
          
          export ECR_REGISTRY=${{ env.ECR_REGISTRY }}
          
          # ê¸°ì¡´ Next.js í´ë¼ì´ì–¸íŠ¸ Pod ì •ë¦¬ (ë¬¸ì œê°€ ìˆëŠ” Podë“¤ ì œê±°)
          echo "ğŸ§¹ Cleaning up existing Next.js Client pods..."
          kubectl delete pods -l app=nextjs-client -n ${{ env.EKS_NAMESPACE }} --ignore-not-found=true || true
          
          # Next.js í´ë¼ì´ì–¸íŠ¸ë§Œ ë¨¼ì € ë°°í¬
          echo "ğŸ“¦ Deploying Next.js Client..."
          if envsubst < k8s/nextjs-client.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}; then
            echo "âœ… Next.js Client deployed successfully"
            
            # ì´ë¯¸ì§€ ì—…ë°ì´íŠ¸
            if kubectl set image deployment/nextjs-client nextjs-client=$ECR_REGISTRY/togather/client:${{ github.sha }} -n ${{ env.EKS_NAMESPACE }} --record=true; then
              echo "âœ… Next.js Client image updated successfully"
              
              # Pod ì¬ì‹œì‘ ëŒ€ê¸°
              echo "â³ Waiting for Next.js Client pods to be ready..."
              kubectl rollout status deployment/nextjs-client -n ${{ env.EKS_NAMESPACE }} --timeout=300s || echo "âš ï¸ Rollout timeout, but continuing..."
            else
              echo "âŒ Next.js Client image update failed"
            fi
          else
            echo "âŒ Next.js Client deployment failed"
          fi

      - name: Build with Gradle (Backend)
        run: |
          chmod +x gradlew
          ./gradlew build -x test

      # --- Spring Services Docker Build (with error handling) ----
      - name: Build and Push API Gateway image
        continue-on-error: true
        run: |
          echo "ğŸš€ Building API Gateway image..."
          if docker build -f api-gateway/Dockerfile -t $ECR_REGISTRY/togather/api-gateway:${{ github.sha }} .; then
            echo "âœ… API Gateway build successful"
            docker tag $ECR_REGISTRY/togather/api-gateway:${{ github.sha }} $ECR_REGISTRY/togather/api-gateway:latest
            if docker push $ECR_REGISTRY/togather/api-gateway:${{ github.sha }} && docker push $ECR_REGISTRY/togather/api-gateway:latest; then
              echo "âœ… API Gateway pushed successfully"
            else
              echo "âŒ API Gateway push failed"
              exit 1
            fi
          else
            echo "âŒ API Gateway build failed"
            exit 1
          fi

      - name: Build and Push User Service image
        continue-on-error: true
        run: |
          echo "ğŸš€ Building User Service image..."
          if docker build -f user-service/Dockerfile -t $ECR_REGISTRY/togather/user-service:${{ github.sha }} .; then
            echo "âœ… User Service build successful"
            docker tag $ECR_REGISTRY/togather/user-service:${{ github.sha }} $ECR_REGISTRY/togather/user-service:latest
            if docker push $ECR_REGISTRY/togather/user-service:${{ github.sha }} && docker push $ECR_REGISTRY/togather/user-service:latest; then
              echo "âœ… User Service pushed successfully"
            else
              echo "âŒ User Service push failed"
              exit 1
            fi
          else
            echo "âŒ User Service build failed"
            exit 1
          fi

      - name: Build and Push Trading Service image
        continue-on-error: true
        run: |
          echo "ğŸš€ Building Trading Service image..."
          if docker build -f trading-service/Dockerfile -t $ECR_REGISTRY/togather/trading-service:${{ github.sha }} .; then
            echo "âœ… Trading Service build successful"
            docker tag $ECR_REGISTRY/togather/trading-service:${{ github.sha }} $ECR_REGISTRY/togather/trading-service:latest
            if docker push $ECR_REGISTRY/togather/trading-service:${{ github.sha }} && docker push $ECR_REGISTRY/togather/trading-service:latest; then
              echo "âœ… Trading Service pushed successfully"
            else
              echo "âŒ Trading Service push failed"
              exit 1
            fi
          else
            echo "âŒ Trading Service build failed"
            exit 1
          fi

      - name: Build and Push Pay Service image
        continue-on-error: true
        run: |
          echo "ğŸš€ Building Pay Service image..."
          if docker build -f pay-service/Dockerfile -t $ECR_REGISTRY/togather/pay-service:${{ github.sha }} .; then
            echo "âœ… Pay Service build successful"
            docker tag $ECR_REGISTRY/togather/pay-service:${{ github.sha }} $ECR_REGISTRY/togather/pay-service:latest
            if docker push $ECR_REGISTRY/togather/pay-service:${{ github.sha }} && docker push $ECR_REGISTRY/togather/pay-service:latest; then
              echo "âœ… Pay Service pushed successfully"
            else
              echo "âŒ Pay Service push failed"
              exit 1
            fi
          else
            echo "âŒ Pay Service build failed"
            exit 1
          fi

      - name: Build and Push Vote Service image
        continue-on-error: true
        run: |
          echo "ğŸš€ Building Vote Service image..."
          if docker build -f vote-service/Dockerfile -t $ECR_REGISTRY/togather/vote-service:${{ github.sha }} .; then
            echo "âœ… Vote Service build successful"
            docker tag $ECR_REGISTRY/togather/vote-service:${{ github.sha }} $ECR_REGISTRY/togather/vote-service:latest
            if docker push $ECR_REGISTRY/togather/vote-service:${{ github.sha }} && docker push $ECR_REGISTRY/togather/vote-service:latest; then
              echo "âœ… Vote Service pushed successfully"
            else
              echo "âŒ Vote Service push failed"
              exit 1
            fi
          else
            echo "âŒ Vote Service build failed"
            exit 1
          fi

      # --- Spring Services Build Summary ---
      - name: Spring Services Build Summary
        run: |
          echo "ğŸ“Š Spring Services Build Summary:"
          echo "=================================="
          echo "âœ… API Gateway: ${{ steps.build-api-gateway.outcome }}"
          echo "âœ… User Service: ${{ steps.build-user-service.outcome }}"
          echo "âœ… Trading Service: ${{ steps.build-trading-service.outcome }}"
          echo "âœ… Pay Service: ${{ steps.build-pay-service.outcome }}"
          echo "âœ… Vote Service: ${{ steps.build-vote-service.outcome }}"


      # --- EKS ë°°í¬ ---
      - name: Configure kubectl for EKS
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Deploy to EKS
        if: github.ref == 'refs/heads/main'
        run: |
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/api-gateway-rbac.yaml -n ${{ env.EKS_NAMESPACE }}

          export ECR_REGISTRY=${{ env.ECR_REGISTRY }}
          export CERTIFICATE_ARN=${{ secrets.CERTIFICATE_ARN }}

          # Secrets ìƒì„±
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Secret
          metadata:
            name: togather-secrets
            namespace: ${{ env.EKS_NAMESPACE }}
          type: Opaque
          stringData:
            SPRING_DATASOURCE_USERNAME: "${{ secrets.DB_USERNAME }}"
            SPRING_DATASOURCE_PASSWORD: "${{ secrets.DB_PASSWORD }}"
            DB_USERNAME: "${{ secrets.DB_USERNAME }}"
            DB_PASSWORD: "${{ secrets.DB_PASSWORD }}"
            JWT_SECRET_KEY: "${{ secrets.JWT_SECRET_KEY }}"
            JWT_SECRET: "${{ secrets.JWT_SECRET_KEY }}"
            SPRING_RABBITMQ_USERNAME: "admin"
            SPRING_RABBITMQ_PASSWORD: "${{ secrets.RABBITMQ_PASSWORD }}"
            REDIS_PASSWORD: "${{ secrets.REDIS_PASSWORD }}"
            SPRING_DATA_REDIS_PASSWORD: "${{ secrets.REDIS_PASSWORD }}"
          EOF

          # ë¦¬ì†ŒìŠ¤ ë°°í¬ (with error handling)
          echo "ğŸš€ Deploying Kubernetes resources..."
          FAILED_DEPLOYMENTS=""
          SUCCESS_DEPLOYMENTS=""
          
          for file in api-gateway user-service trading-service pay-service vote-service ingress; do
            echo "ğŸ“¦ Deploying $file..."
            if envsubst < k8s/$file.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}; then
              echo "âœ… $file deployed successfully"
              SUCCESS_DEPLOYMENTS="$SUCCESS_DEPLOYMENTS $file"
            else
              echo "âŒ $file deployment failed"
              FAILED_DEPLOYMENTS="$FAILED_DEPLOYMENTS $file"
            fi
          done

          # Additional resources
          echo "ğŸ“¦ Deploying additional resources..."
          for resource in configmap redis rabbitmq hpa; do
            echo "ğŸ“¦ Deploying $resource..."
            if kubectl apply -f k8s/$resource.yaml -n ${{ env.EKS_NAMESPACE }}; then
              echo "âœ… $resource deployed successfully"
              SUCCESS_DEPLOYMENTS="$SUCCESS_DEPLOYMENTS $resource"
            else
              echo "âŒ $resource deployment failed"
              FAILED_DEPLOYMENTS="$FAILED_DEPLOYMENTS $resource"
            fi
          done

          # ìµœì‹  ì´ë¯¸ì§€ ë°˜ì˜ (with error handling)
          echo "ğŸ”„ Updating service images..."
          for svc in api-gateway user-service trading-service pay-service vote-service; do
            echo "ğŸ”„ Updating $svc image..."
            if kubectl set image deployment/$svc $svc=$ECR_REGISTRY/togather/$svc:${{ github.sha }} -n ${{ env.EKS_NAMESPACE }} --record=true; then
              echo "âœ… $svc image updated successfully"
            else
              echo "âŒ $svc image update failed"
              FAILED_DEPLOYMENTS="$FAILED_DEPLOYMENTS $svc-image"
            fi
          done

          # ë°°í¬ ê²°ê³¼ ìš”ì•½
          echo ""
          echo "ğŸ“Š Deployment Summary:"
          echo "====================="
          if [ -n "$SUCCESS_DEPLOYMENTS" ]; then
            echo "âœ… Successful: $SUCCESS_DEPLOYMENTS"
          fi
          if [ -n "$FAILED_DEPLOYMENTS" ]; then
            echo "âŒ Failed: $FAILED_DEPLOYMENTS"
            echo "âš ï¸ Some deployments failed, but continuing..."
          fi

          # Next.js í´ë¼ì´ì–¸íŠ¸ ìµœì¢… ìƒíƒœ í™•ì¸
          echo ""
          echo "ğŸ” Next.js Client Final Status:"
          echo "==============================="
          kubectl get pods -l app=nextjs-client -n ${{ env.EKS_NAMESPACE }} -o wide || echo "âŒ Failed to get Next.js Client pods"
          
          # Next.js í´ë¼ì´ì–¸íŠ¸ Health Check
          echo ""
          echo "ğŸ¥ Next.js Client Health Check:"
          NEXTJS_POD=$(kubectl get pods -l app=nextjs-client -n ${{ env.EKS_NAMESPACE }} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "$NEXTJS_POD" ]; then
            echo "ğŸ“‹ Pod: $NEXTJS_POD"
            kubectl logs $NEXTJS_POD -n ${{ env.EKS_NAMESPACE }} --tail=20 || echo "âŒ Failed to get logs"
          else
            echo "âŒ No Next.js Client pod found"
          fi

      # --- ë°°í¬ ì™„ë£Œ í›„ Prewarm ---
      - name: Prewarm Next.js Client
        if: github.ref == 'refs/heads/main'
        run: |
          echo "ğŸ”¥ Prewarming Next.js..."
          SITE_URL="https://xn--o79aq2k062a.store"
          for i in {1..5}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$SITE_URL" || echo "000")
            echo "Request $i => HTTP $STATUS"
            sleep 3
          done
          echo "âœ… Prewarm completed!"


      # --- ê°„ë‹¨í•œ ë°°í¬ ìƒíƒœ í™•ì¸ ---
      - name: Quick Deployment Check
        if: always()
        run: |
          echo "ğŸ” Quick Deployment Check"
          echo "========================"
          kubectl get pods -n ${{ env.EKS_NAMESPACE }} || echo "âŒ Failed to get pods"

      # --- ì—ëŸ¬ ë°œìƒ ì‹œ ê°„ë‹¨í•œ ì§„ë‹¨ ---
      - name: Quick Error Diagnostics
        if: failure()
        run: |
          echo "ğŸš¨ DEPLOYMENT FAILED - Quick diagnostics..."
          kubectl get pods -n ${{ env.EKS_NAMESPACE }} || echo "âŒ Failed to get pods"
          kubectl get events -n ${{ env.EKS_NAMESPACE }} --sort-by='.lastTimestamp' | tail -10 || echo "âŒ Failed to get events"


#name: Deploy ToGather Microservices to AWS EKS
#
#on:
#  push:
#    branches: [ main ]
#  pull_request:
#    branches: [ main ]
#  workflow_dispatch:
#
#env:
#  AWS_REGION: ap-northeast-2
#  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.ap-northeast-2.amazonaws.com
#  EKS_CLUSTER_NAME: togather-cluster
#  EKS_NAMESPACE: togather
#  # CDN ì„¤ì •!
#  CDN_URL: https://d36ue99r8i68ow.cloudfront.net
#  S3_BUCKET_NAME: togather-static-assets
#  CLOUDFRONT_DISTRIBUTION_ID: E15ZDIW40YBVEN
#
#jobs:
#  build-and-deploy:
#    runs-on: ubuntu-latest
#
#    steps:
#      - name: Checkout code
#        uses: actions/checkout@v4
#
#      - name: Set gradlew permissions
#        run: chmod +x gradlew
#
#      - name: Configure AWS credentials
#        uses: aws-actions/configure-aws-credentials@v4
#        with:
#          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#          aws-region: ${{ env.AWS_REGION }}
#
#      - name: Login to Amazon ECR
#        id: login-ecr
#        uses: aws-actions/amazon-ecr-login@v2
#
#      - name: Checkout Client Repo # ToGather-Client ì ‘ê·¼!
#        uses: actions/checkout@v4
#        with:
#          repository: ToGather-Final/ToGather-Client
#          token: ${{ secrets.GH_PAT }}
#          path: togather-client
#
#      - name: Setup pnpm
#        uses: pnpm/action-setup@v4
#        with:
#          version: latest
#
#      - name: Cache pnpm dependencies
#        uses: actions/cache@v3
#        with:
#          path: |
#            ~/.pnpm-store
#            togather-client/node_modules
#          key: ${{ runner.os }}-pnpm-${{ hashFiles('togather-client/pnpm-lock.yaml') }}
#          restore-keys: |
#            ${{ runner.os }}-pnpm-
#
#      - name: Set up JDK 17
#        uses: actions/setup-java@v4
#        with:
#          java-version: '17'
#          distribution: 'temurin'
#
#      - name: Cache Gradle packages
#        uses: actions/cache@v3
#        with:
#          path: |
#            ~/.gradle/caches
#            ~/.gradle/wrapper
#          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*') }}
#          restore-keys: |
#            ${{ runner.os }}-gradle-
#
#      - name: Build with Gradle
#        run: |
#          chmod +x gradlew
#          ./gradlew build -x test
#
#      #    - name: Build and push Next.js Client image
#      #      run: |
#      #        docker build -t $ECR_REGISTRY/togather/client:${{ github.sha }} -f ./togather-client/Dockerfile ./togather-client
#      #        docker build -t $ECR_REGISTRY/togather/client:latest -f ./togather-client/Dockerfile ./togather-client
#      #        docker push $ECR_REGISTRY/togather/client:${{ github.sha }}
#      #        docker push $ECR_REGISTRY/togather/client:latest
#
#      - name: Build Next.js Client and upload static assets
#        run: |
#          cd togather-client
#          export CDN_URL_CLEAN=$(echo "${{ env.CDN_URL }}" | sed 's:/*$::')
#          echo "ğŸ›° Using CDN_URL=$CDN_URL_CLEAN"
#
#          pnpm install --frozen-lockfile
#
#          # âœ… Next.js ë¹Œë“œ (ë‹¨ 1íšŒ)
#          SERVER_API_BASE_URL=http://api-gateway.togather.svc.cluster.local:8000/api \
#          NEXT_PUBLIC_API_BASE_URL=https://xn--o79aq2k062a.store/api \
#          CDN_URL=$CDN_URL_CLEAN pnpm run build
#
#          # âœ… ë¹Œë“œ ì‚°ì¶œë¬¼ ì•„í‹°íŒ©íŠ¸ë¡œ ë³´ê´€ (Dockerì™€ S3ì—ì„œ ë™ì¼ ë¹Œë“œ ì‚¬ìš©)
#          cd ..
#          tar -czf next-artifacts.tgz -C togather-client .next/standalone .next/static .next/server public
#          echo "âœ… next-artifacts.tgz ìƒì„± ì™„ë£Œ"
#
#          # âœ… ì •ì  ìì‚° ì—…ë¡œë“œ ë° CDN ë¬´íš¨í™”
#          cd togather-client
#          pnpm run upload-assets
#        env:
#          CDN_URL: ${{ env.CDN_URL }}
#          S3_BUCKET_NAME: ${{ env.S3_BUCKET_NAME }}
#          CLOUDFRONT_DISTRIBUTION_ID: ${{ env.CLOUDFRONT_DISTRIBUTION_ID }}
#          NEXT_PUBLIC_API_BASE_URL: https://xn--o79aq2k062a.store
#
#        # âœ… next-artifacts.tgz íŒŒì¼ì„ ì—…ë¡œë“œ (ë¹Œë“œ ê²°ê³¼ ë°±ì—…)
#      - name: Upload Next build artifacts
#        uses: actions/upload-artifact@v4
#        with:
#          name: next-artifacts
#          path: next-artifacts.tgz
#
#        # âœ… ë¹Œë“œ ê²°ê³¼ë¥¼ Docker ì´ë¯¸ì§€ ìƒì„±ì— ì¬ì‚¬ìš©
#      - name: Download Next.js build artifacts
#        uses: actions/download-artifact@v4
#        with:
#          name: next-artifacts
#          path: ./togather-client
#
#            echo "âœ… Next.js build completed. Checking output structure..."
#            ls -R .next | head -n 40
#
#            # âœ… server entry ê²€ì¦
#            if [ ! -f ".next/standalone/server.js" ] && [ ! -f ".next/standalone/server.mjs" ]; then
#            echo "âŒ .next/standalone/server.js(.mjs) not found!"
#            echo "ë¹Œë“œ ì‚°ì¶œë¬¼ ëˆ„ë½. ë¹Œë“œ ì‹¤íŒ¨ë¡œ ê°„ì£¼í•©ë‹ˆë‹¤."
#            ls -R .next/standalone | head -n 50 || true
#            exit 1
#            fi
#
#
#            # âœ… ë¹Œë“œ ì‚°ì¶œë¬¼ ì•„í‹°íŒ©íŠ¸ë¡œ ë³´ê´€ (Dockerì™€ S3ì—ì„œ ë™ì¼ ë¹Œë“œ ì‚¬ìš©)!!!
#            cd ..
#            tar -czf next-artifacts.tgz -C togather-client .next/standalone .next/static public
#            echo "âœ… next-artifacts.tgz ìƒì„± ì™„ë£Œ"
#
#      - name: Build and push Next.js runtime image
#        run: |
#          echo "ğŸš€ Building Next.js runtime image..."
#          docker build \
#            --build-arg SERVER_API_BASE_URL=http://api-gateway.togather.svc.cluster.local:8000/api \
#            --build-arg NEXT_PUBLIC_API_BASE_URL=https://xn--o79aq2k062a.store/api \
#            --build-arg CDN_URL=${{ env.CDN_URL }} \
#            -t $ECR_REGISTRY/togather/client:${{ github.sha }} \
#            -f ./togather-client/Dockerfile ./togather-client
#
#          # âœ… íƒœê·¸ ë° í‘¸ì‹œ
#          docker tag $ECR_REGISTRY/togather/client:${{ github.sha }} $ECR_REGISTRY/togather/client:latest
#          docker push $ECR_REGISTRY/togather/client:${{ github.sha }}
#          docker push $ECR_REGISTRY/togather/client:latest
#
#          # âœ… ë¹Œë“œ ê²€ì¦ ë¡œê·¸
#          echo "âœ… Docker image for Next.js successfully built and pushed!"
#
#
#      - name: Upload Next build artifacts
#        uses: actions/upload-artifact@v4
#        with:
#          name: next-artifacts
#          path: next-artifacts.tgz
#
#      - name: Download Next.js build artifacts
#        uses: actions/download-artifact@v4
#        with:
#          name: next-artifacts
#          path: ./togather-client
#
#      - name: Extract Next.js artifacts
#        run: |
#          tar -xzf ./togather-client/next-artifacts.tgz -C ./togather-client
#          echo "âœ… next-artifacts.tgz ì••ì¶• í•´ì œ ì™„ë£Œ"
#          ls -R ./togather-client/.next/standalone | head -n 20
#
#        # âœ… kr ë„ì…ì„ ìœ„í•´ ì¶”ê°€ --build-arg CDN_URL=${{ env.CDN_URL }} \
#      - name: Build and push Next.js runtime image
#        run: |
#          echo "ğŸš€ Building Next.js runtime image..."
#          cd togather-client
#
#          # ë¹Œë“œ ì‚°ì¶œë¬¼ ê²€ì¦
#          if [ ! -f ".next/standalone/server.js" ]; then
#          echo "âŒ server.js not found in .next/standalone â€” build failed!"
#          ls -R .next | head -n 40
#          exit 1
#          fi
#
#          docker build \
#          --build-arg SERVER_API_BASE_URL=http://api-gateway.togather.svc.cluster.local:8000/api \
#          --build-arg NEXT_PUBLIC_API_BASE_URL=https://xn--o79aq2k062a.store/api \
#          --build-arg CDN_URL=${{ env.CDN_URL }} \
#          -t $ECR_REGISTRY/togather/client:${{ github.sha }} \
#          -t $ECR_REGISTRY/togather/client:latest \
#          -f Dockerfile .
#
#          docker push $ECR_REGISTRY/togather/client:${{ github.sha }}
#          docker push $ECR_REGISTRY/togather/client:latest
#
#          - name: Build and push Vote Service image
#            run: |
#              docker build -f vote-service/Dockerfile -t $ECR_REGISTRY/togather/vote-service:${{ github.sha }} .
#              docker build -f vote-service/Dockerfile -t $ECR_REGISTRY/togather/vote-service:latest .
#              docker push $ECR_REGISTRY/togather/vote-service:${{ github.sha }}
#              docker push $ECR_REGISTRY/togather/vote-service:latest
#
#          - name: Install kubectl
#            uses: azure/setup-kubectl@v3
#            with:
#              version: 'v1.28.0'
#
#          - name: Configure kubectl for EKS
#            run: |
#              aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
#
#          - name: Deploy to EKS
#            if: github.ref == 'refs/heads/main'
#            run: |
#              # 1. ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ìƒì„± (ì—†ìœ¼ë©´ ìƒì„±, ìˆìœ¼ë©´ ë„˜ì–´ê°)
#              kubectl apply -f k8s/namespace.yaml
#
#              # 2. Secret ìƒì„± (ëª¨ë“  ë¯¼ê° ì •ë³´ë¥¼ GitHub Secretsì—ì„œ ê°€ì ¸ì™€ í†µí•©)
#              kubectl apply -f - <<EOF
#              apiVersion: v1
#              kind: Secret
#              metadata:
#                name: togather-secrets
#                namespace: ${{ env.EKS_NAMESPACE }}
#              type: Opaque
#              stringData:
#                SPRING_DATASOURCE_USERNAME: "${{ secrets.DB_USERNAME }}"
#                SPRING_DATASOURCE_PASSWORD: "${{ secrets.DB_PASSWORD }}"
#                DB_USERNAME: "${{ secrets.DB_USERNAME }}"
#                DB_PASSWORD: "${{ secrets.DB_PASSWORD }}"
#                JWT_SECRET_KEY: "${{ secrets.JWT_SECRET_KEY }}"
#                JWT_SECRET: "${{ secrets.JWT_SECRET_KEY }}"
#                SPRING_RABBITMQ_USERNAME: "admin"
#                SPRING_RABBITMQ_PASSWORD: "${{ secrets.RABBITMQ_PASSWORD }}"
#                RABBITMQ_USERNAME: "admin"
#                RABBITMQ_PASSWORD: "${{ secrets.RABBITMQ_PASSWORD }}"
#                REDIS_PASSWORD: "${{ secrets.REDIS_PASSWORD }}"
#                SPRING_DATA_REDIS_PASSWORD: "${{ secrets.REDIS_PASSWORD }}"
#                # KIS ì¦ê¶Œ API í™˜ê²½ë³€ìˆ˜
#                KIS_BASE_URL: "${{ secrets.KIS_BASE_URL }}"
#                KIS_APPKEY: "${{ secrets.KIS_APPKEY }}"
#                KIS_APPSECRET: "${{ secrets.KIS_APPSECRET }}"
#              EOF
#
#              # 3. RBAC ë¨¼ì € ì ìš© (ServiceAccount/Role/RoleBinding)
#              kubectl apply -f k8s/api-gateway-rbac.yaml -n ${{ env.EKS_NAMESPACE }}
#
#              # 4. í™˜ê²½ë³€ìˆ˜ ì¹˜í™˜ í›„ ë‚˜ë¨¸ì§€ ëª¨ë“  ë¦¬ì†ŒìŠ¤ ë°°í¬
#              # ECR_REGISTRYì™€ CERTIFICATE_ARN í™˜ê²½ë³€ìˆ˜ë¥¼ k8s íŒŒì¼ë“¤ì— ì¹˜í™˜
#              export ECR_REGISTRY=${{ env.ECR_REGISTRY }}
#              export CERTIFICATE_ARN=${{ secrets.CERTIFICATE_ARN }}
#
#              # í™˜ê²½ë³€ìˆ˜ ì¹˜í™˜ì´ í•„ìš”í•œ íŒŒì¼ë“¤ ë°°í¬
#              envsubst < k8s/api-gateway.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}
#              envsubst < k8s/user-service.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}
#              envsubst < k8s/trading-service.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}
#              envsubst < k8s/pay-service.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}
#              envsubst < k8s/vote-service.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}
#              envsubst < k8s/nextjs-client.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}
#              envsubst < k8s/ingress.yaml | kubectl apply -f - -n ${{ env.EKS_NAMESPACE }}
#
#              # ë‚˜ë¨¸ì§€ ë¦¬ì†ŒìŠ¤ë“¤ (ConfigMap, Service, HPA ë“±) ë°°í¬
#              kubectl apply -f k8s/configmap.yaml -n ${{ env.EKS_NAMESPACE }}
#              kubectl apply -f k8s/configmap-env.yaml -n ${{ env.EKS_NAMESPACE }}
#              kubectl apply -f k8s/redis.yaml -n ${{ env.EKS_NAMESPACE }}
#              kubectl apply -f k8s/rabbitmq.yaml -n ${{ env.EKS_NAMESPACE }}
#              # ingress.yamlê³¼ nextjs-client.yamlì€ ìœ„ì—ì„œ envsubstë¡œ ì´ë¯¸ ë°°í¬ë¨
#              kubectl apply -f k8s/hpa.yaml -n ${{ env.EKS_NAMESPACE }}  # ğŸš€ HPA ì¬í™œì„±í™”
#
#              # 5. ê° ë””í”Œë¡œì´ë¨¼íŠ¸ì— ì»¤ë°‹ SHA ì´ë¯¸ì§€ ì„¤ì • (ë¡¤ì•„ì›ƒ íŠ¸ë¦¬ê±°)
#              kubectl set image deployment/api-gateway api-gateway=${{ env.ECR_REGISTRY }}/togather/api-gateway:${{ github.sha }} -n ${{ env.EKS_NAMESPACE }} --record=true
#              kubectl set image deployment/user-service user-service=${{ env.ECR_REGISTRY }}/togather/user-service:${{ github.sha }} -n ${{ env.EKS_NAMESPACE }} --record=true
#              kubectl set image deployment/trading-service trading-service=${{ env.ECR_REGISTRY }}/togather/trading-service:${{ github.sha }} -n ${{ env.EKS_NAMESPACE }} --record=true
#              kubectl set image deployment/pay-service pay-service=${{ env.ECR_REGISTRY }}/togather/pay-service:${{ github.sha }} -n ${{ env.EKS_NAMESPACE }} --record=true
#              kubectl set image deployment/vote-service vote-service=${{ env.ECR_REGISTRY }}/togather/vote-service:${{ github.sha }} -n ${{ env.EKS_NAMESPACE }} --record=true
#              kubectl set image deployment/nextjs-client nextjs-client=${{ env.ECR_REGISTRY }}/togather/client:${{ github.sha }} -n ${{ env.EKS_NAMESPACE }} --record=true
#
#          - name: Invalidate CloudFront Cache
#            if: github.ref == 'refs/heads/main'
#            uses: chetan/invalidate-cloudfront-action@v2
#            env:
#              DISTRIBUTION: ${{ env.CLOUDFRONT_DISTRIBUTION_ID }}
#              PATHS: "/*" # ğŸ’¡ ëª¨ë“  íŒŒì¼(*)ì„ ë¬´íš¨í™”í•˜ì—¬ ì¦‰ì‹œ ë³€ê²½ì‚¬í•­ ë°˜ì˜d
#              AWS_REGION: "us-east-1" # ì¸ì¦ì„œëŠ” us-east-1ì— ìˆì–´ì•¼ í•˜ë¯€ë¡œ ëª…ì‹œ
#              AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
#              AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#
#          - name: Wait for deployment to complete
#            if: github.ref == 'refs/heads/main'
#            run: |
#              # ë°°í¬ ê²°ê³¼ ì¶”ì ì„ ìœ„í•œ ë³€ìˆ˜ ì´ˆê¸°í™”
#              FAILED_SERVICES=""
#              SUCCESS_SERVICES=""
#
#              # Redis ë°°í¬ í™•ì¸
#              echo "ğŸš€ Redis ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
#              if kubectl rollout status deployment/redis -n ${{ env.EKS_NAMESPACE }} --timeout=60s; then
#                echo "âœ… Redis ë°°í¬ ì„±ê³µ"
#                SUCCESS_SERVICES="$SUCCESS_SERVICES redis"
#              else
#                echo "âŒ Redis ë°°í¬ ì‹¤íŒ¨! ì§„ë‹¨ ì •ë³´ ì¶œë ¥ ì¤‘..."
#                FAILED_SERVICES="$FAILED_SERVICES redis"
#                kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=redis
#                kubectl describe deployment redis -n ${{ env.EKS_NAMESPACE }}
#                POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=redis -o jsonpath='{.items[0].metadata.name}')
#                kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
#                kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=100 || true
#              fi
#
#              # API Gateway ë°°í¬ í™•ì¸!!
#              echo ""
#              echo "ğŸš€ API Gateway ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
#              if kubectl rollout status deployment/api-gateway -n ${{ env.EKS_NAMESPACE }} --timeout=240s; then
#                echo "âœ… API Gateway ë°°í¬ ì„±ê³µ"
#                SUCCESS_SERVICES="$SUCCESS_SERVICES api-gateway"
#              else
#                echo "âŒ API Gateway ë°°í¬ ì‹¤íŒ¨! ì§„ë‹¨ ì •ë³´ ì¶œë ¥ ì¤‘..."
#                FAILED_SERVICES="$FAILED_SERVICES api-gateway"
#                kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=api-gateway
#                kubectl describe deployment api-gateway -n ${{ env.EKS_NAMESPACE }}
#                POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=api-gateway -o jsonpath='{.items[0].metadata.name}')
#                kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
#                kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=100 || true
#              fi
#
#              # User Service ë°°í¬ í™•ì¸
#              echo ""
#              echo "ğŸš€ User Service ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
#              if kubectl rollout status deployment/user-service -n ${{ env.EKS_NAMESPACE }} --timeout=180s; then
#                echo "âœ… User Service ë°°í¬ ì„±ê³µ"
#                SUCCESS_SERVICES="$SUCCESS_SERVICES user-service"
#              else
#                echo "âŒ User Service ë°°í¬ ì‹¤íŒ¨! ì§„ë‹¨ ì •ë³´ ì¶œë ¥ ì¤‘..."
#                FAILED_SERVICES="$FAILED_SERVICES user-service"
#                kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=user-service
#                kubectl describe deployment user-service -n ${{ env.EKS_NAMESPACE }}
#                POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=user-service -o jsonpath='{.items[0].metadata.name}')
#                kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
#                kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=100 || true
#              fi
#
#              # Trading Service ë°°í¬ í™•ì¸
#              echo ""
#              echo "ğŸš€ Trading Service ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
#              if kubectl rollout status deployment/trading-service -n ${{ env.EKS_NAMESPACE }} --timeout=180s; then
#                echo "âœ… Trading Service ë°°í¬ ì„±ê³µ"
#                SUCCESS_SERVICES="$SUCCESS_SERVICES trading-service"
#              else
#                echo "âŒ Trading Service ë°°í¬ ì‹¤íŒ¨! ì§„ë‹¨ ì •ë³´ ì¶œë ¥ ì¤‘..."
#                FAILED_SERVICES="$FAILED_SERVICES trading-service"
#                kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=trading-service
#                kubectl describe deployment trading-service -n ${{ env.EKS_NAMESPACE }}
#                POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=trading-service -o jsonpath='{.items[0].metadata.name}')
#                kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
#                kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=100 || true
#              fi
#
#              # Pay Service ë°°í¬ í™•ì¸
#              echo ""
#              echo "ğŸš€ Pay Service ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
#              if kubectl rollout status deployment/pay-service -n ${{ env.EKS_NAMESPACE }} --timeout=180s; then
#                echo "âœ… Pay Service ë°°í¬ ì„±ê³µ"
#                SUCCESS_SERVICES="$SUCCESS_SERVICES pay-service"
#              else
#                echo "âŒ Pay Service ë°°í¬ ì‹¤íŒ¨! ì§„ë‹¨ ì •ë³´ ì¶œë ¥ ì¤‘..."
#                FAILED_SERVICES="$FAILED_SERVICES pay-service"
#                kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=pay-service
#                kubectl describe deployment pay-service -n ${{ env.EKS_NAMESPACE }}
#                POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=pay-service -o jsonpath='{.items[0].metadata.name}')
#                kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
#                kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=100 || true
#              fi
#
#              # Vote Service ë°°í¬ í™•ì¸
#              echo ""
#              echo "ğŸš€ Vote Service ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
#              if kubectl rollout status deployment/vote-service -n ${{ env.EKS_NAMESPACE }} --timeout=180s; then
#                echo "âœ… Vote Service ë°°í¬ ì„±ê³µ"
#                SUCCESS_SERVICES="$SUCCESS_SERVICES vote-service"
#              else
#                echo "âŒ Vote Service ë°°í¬ ì‹¤íŒ¨! ì§„ë‹¨ ì •ë³´ ì¶œë ¥ ì¤‘..."
#                FAILED_SERVICES="$FAILED_SERVICES vote-service"
#                kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=vote-service
#                kubectl describe deployment vote-service -n ${{ env.EKS_NAMESPACE }}
#                POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=vote-service -o jsonpath='{.items[0].metadata.name}')
#                kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
#                kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=100 || true
#              fi
#
#              # Next.js Client ë°°í¬ í™•ì¸
#              echo ""
#              echo "ğŸš€ Next.js Client ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
#              if kubectl rollout status deployment/nextjs-client -n ${{ env.EKS_NAMESPACE }} --timeout=120s; then
#                echo "âœ… Next.js Client ë°°í¬ ì„±ê³µ"
#                SUCCESS_SERVICES="$SUCCESS_SERVICES nextjs-client"
#              else
#                echo "âŒ Next.js Client ë°°í¬ ì‹¤íŒ¨! ì§„ë‹¨ ì •ë³´ ì¶œë ¥ ì¤‘..."
#                FAILED_SERVICES="$FAILED_SERVICES nextjs-client"
#                kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=nextjs-client
#                kubectl describe deployment nextjs-client -n ${{ env.EKS_NAMESPACE }}
#                POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=nextjs-client -o jsonpath='{.items[0].metadata.name}')
#                kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
#                kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=100 || true
#              fi
#
#              # ìµœì¢… ë°°í¬ ê²°ê³¼ ìš”ì•½
#              echo ""
#              echo "=================================================="
#              echo "ğŸ“Š ë°°í¬ ê²°ê³¼ ìš”ì•½"
#              echo "=================================================="
#
#              if [ -n "$SUCCESS_SERVICES" ]; then
#                echo "âœ… ì„±ê³µí•œ ì„œë¹„ìŠ¤:$SUCCESS_SERVICES"
#              fi
#
#              if [ -n "$FAILED_SERVICES" ]; then
#                echo "âŒ ì‹¤íŒ¨í•œ ì„œë¹„ìŠ¤:$FAILED_SERVICES"
#                echo ""
#                echo "âš ï¸ ì¼ë¶€ ì„œë¹„ìŠ¤ ë°°í¬ê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤!"
#                exit 1
#              else
#                echo ""
#                echo "ğŸ‰ ëª¨ë“  ì„œë¹„ìŠ¤ ë°°í¬ ì™„ë£Œ!"
#              fi
#
#          - name: Verify deployment
#            if: github.ref == 'refs/heads/main'
#            run: |
#              kubectl get pods -n ${{ env.EKS_NAMESPACE }}
#              kubectl get services -n ${{ env.EKS_NAMESPACE }}
#              kubectl get ingress -n ${{ env.EKS_NAMESPACE }}
#
#          - name: Prewarm Next.js Client
#            if: github.ref == 'refs/heads/main'
#            run: |
#              echo "ğŸ”¥ Next.js í´ë¼ì´ì–¸íŠ¸ Prewarming ì‹œì‘..."
#              SITE_URL="https://xn--o79aq2k062a.store"
#
#              # ë°°í¬ ì™„ë£Œ ëŒ€ê¸° (ìµœëŒ€ 2ë¶„)
#              echo "â³ Next.js í´ë¼ì´ì–¸íŠ¸ ì¤€ë¹„ ëŒ€ê¸° ì¤‘..."
#              for i in {1..24}; do
#                if kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=nextjs-client -o jsonpath='{.items[0].status.conditions[?(@.type=="Ready")].status}' | grep -q "True"; then
#                  echo "âœ… Next.js í´ë¼ì´ì–¸íŠ¸ ì¤€ë¹„ ì™„ë£Œ!"
#                  break
#                fi
#                echo "ëŒ€ê¸° ì¤‘... ($i/24)"
#                sleep 5
#              done
#
#              # Prewarming ìš”ì²­ (5íšŒ)
#              echo "ğŸ”¥ ì›Œë°ì—… ìš”ì²­ ì „ì†¡ ì¤‘..."
#              for i in {1..5}; do
#                STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$SITE_URL" || echo "000")
#                if [ "$STATUS_CODE" = "200" ]; then
#                  echo "âœ… ì›Œë°ì—… ìš”ì²­ $i/5 ì„±ê³µ (HTTP $STATUS_CODE)"
#                else
#                  echo "âš ï¸ ì›Œë°ì—… ìš”ì²­ $i/5 ì‹¤íŒ¨ (HTTP $STATUS_CODE)"
#                fi
#                sleep 1
#              done
#
#              echo "ğŸ‰ Prewarming ì™„ë£Œ! ì‚¬ìš©ìë“¤ì´ ë¹ ë¥¸ ì‘ë‹µì„ ê²½í—˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
#
#          - name: Diagnostics on failure
#            if: failure()
#            run: |
#              kubectl get deploy -n ${{ env.EKS_NAMESPACE }}
#              kubectl describe deploy api-gateway -n ${{ env.EKS_NAMESPACE }}
#              kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=api-gateway -o wide
#              POD=$(kubectl get pods -n ${{ env.EKS_NAMESPACE }} -l app=api-gateway -o jsonpath='{.items[0].metadata.name}')
#              kubectl describe pod $POD -n ${{ env.EKS_NAMESPACE }} || true
#              kubectl logs $POD -n ${{ env.EKS_NAMESPACE }} --tail=200 || true